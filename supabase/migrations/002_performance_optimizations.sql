-- Performance Optimization Migration for ANOINT Array
-- Generated by PerfProbe Performance Analysis
-- Date: 2025-01-30
-- 
-- This migration adds critical performance optimizations including:
-- - JSONB indexes for fast item searches
-- - Composite indexes for common query patterns  
-- - Partial indexes for filtered queries
-- - RLS policy optimizations
-- - Performance monitoring functions

-- Enable required extensions
CREATE EXTENSION IF NOT EXISTS pg_stat_statements;
CREATE EXTENSION IF NOT EXISTS btree_gin;

-- =============================================================================
-- PHASE 1: CRITICAL JSONB AND COMPOSITE INDEXES
-- =============================================================================

-- 1. JSONB Performance Indexes
-- GIN index for fast JSONB searches on order items
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_orders_items_gin 
ON public.orders USING GIN (items);

-- Specific JSONB path indexes for common product searches
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_orders_items_product_searches 
ON public.orders USING GIN ((items -> 'id'));

-- Index for order totals stored in JSONB
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_orders_total_amount_calc 
ON public.orders USING BTREE (total_amount, status) 
WHERE status IN ('paid', 'processing', 'shipped', 'delivered');

-- 2. Composite Indexes for Common Query Patterns
-- Customer order history with status filtering (most common query)
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_orders_customer_status_date 
ON public.orders (customer_email, status, created_at DESC) 
WHERE status IN ('paid', 'processing', 'shipped', 'delivered');

-- Admin dashboard queries - order management
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_orders_admin_dashboard 
ON public.orders (status, payment_status, created_at DESC)
WHERE status != 'cancelled';

-- Payment processing queries
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_orders_payment_lookup 
ON public.orders (stripe_session_id, paypal_order_id, payment_status)
WHERE payment_status IN ('pending', 'completed');

-- 3. Product Catalog Performance Indexes
-- Product catalog browsing (active products only)
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_products_catalog_active 
ON public.products (category, price ASC, created_at DESC) 
WHERE is_active = true;

-- Product search and filtering
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_products_search 
ON public.products USING GIN (to_tsvector('english', title || ' ' || COALESCE(description, '')))
WHERE is_active = true;

-- Stock management
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_products_stock 
ON public.products (stock_quantity, is_active, updated_at DESC)
WHERE is_active = true;

-- 4. Partial Indexes for Filtered Queries
-- Recent orders (last 90 days) - most queries focus on recent data
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_orders_recent 
ON public.orders (customer_email, created_at DESC, status) 
WHERE created_at >= NOW() - INTERVAL '90 days';

-- Failed payments for retry logic
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_orders_failed_payments 
ON public.orders (customer_email, created_at DESC, payment_method) 
WHERE payment_status = 'failed';

-- Pending orders for processing
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_orders_pending 
ON public.orders (created_at ASC, payment_method)
WHERE status = 'pending' AND created_at >= NOW() - INTERVAL '24 hours';

-- 5. Coupon Performance Indexes
-- Active coupon lookups
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_coupons_active_lookup 
ON public.coupons (code, is_active, expiration_date)
WHERE is_active = true;

-- Usage tracking
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_coupons_usage 
ON public.coupons (used_count, usage_limit, is_active)
WHERE is_active = true AND usage_limit IS NOT NULL;

-- =============================================================================
-- PHASE 2: RLS POLICY OPTIMIZATIONS
-- =============================================================================

-- Create optimized functions for RLS policies
CREATE OR REPLACE FUNCTION auth.email() 
RETURNS TEXT AS $$
BEGIN
  RETURN COALESCE(
    current_setting('request.jwt.claims', true)::json->>'email',
    (auth.jwt() ->> 'email')
  );
END;
$$ LANGUAGE plpgsql STABLE SECURITY DEFINER;

-- Create function index for normalized email comparisons
CREATE INDEX CONCURRENTLY IF NOT EXISTS idx_orders_email_normalized 
ON public.orders (lower(trim(customer_email)));

-- Update RLS policies with optimized conditions
DROP POLICY IF EXISTS "Users can view own orders" ON public.orders;
CREATE POLICY "Users can view own orders" ON public.orders
  FOR SELECT USING (
    lower(trim(customer_email)) = lower(trim(auth.email()))
  );

-- Optimized policy for order updates (if needed)
DROP POLICY IF EXISTS "Users can update own pending orders" ON public.orders;
CREATE POLICY "Users can update own pending orders" ON public.orders
  FOR UPDATE USING (
    lower(trim(customer_email)) = lower(trim(auth.email()))
    AND status = 'pending'
    AND created_at >= NOW() - INTERVAL '1 hour'
  );

-- =============================================================================
-- PHASE 3: PERFORMANCE MONITORING AND ANALYTICS
-- =============================================================================

-- Performance monitoring view
CREATE OR REPLACE VIEW public.database_performance AS
SELECT 
  'active_connections' as metric,
  COUNT(*)::INTEGER as current_value,
  80 as threshold,
  CASE WHEN COUNT(*) > 80 THEN 'warning' ELSE 'normal' END as status
FROM pg_stat_activity
WHERE state = 'active'

UNION ALL

SELECT 
  'cache_hit_ratio' as metric,
  ROUND(
    100.0 * SUM(blks_hit) / NULLIF(SUM(blks_hit + blks_read), 0), 1
  )::INTEGER as current_value,
  90 as threshold,
  CASE 
    WHEN SUM(blks_hit + blks_read) = 0 THEN 'no_data'
    WHEN 100.0 * SUM(blks_hit) / SUM(blks_hit + blks_read) < 90 THEN 'warning'
    ELSE 'normal' 
  END as status
FROM pg_stat_database
WHERE datname = current_database()

UNION ALL

SELECT 
  'slow_queries_last_hour' as metric,
  COUNT(*)::INTEGER as current_value,
  10 as threshold,
  CASE WHEN COUNT(*) > 10 THEN 'warning' ELSE 'normal' END as status
FROM pg_stat_statements 
WHERE last_exec > NOW() - INTERVAL '1 hour'
  AND mean_exec_time > 1000;

-- Query performance analysis function
CREATE OR REPLACE FUNCTION public.get_slow_queries(
  min_duration_ms INTEGER DEFAULT 1000,
  limit_results INTEGER DEFAULT 20
)
RETURNS TABLE (
  query_hash TEXT,
  query_sample TEXT,
  calls BIGINT,
  total_time_ms NUMERIC,
  avg_time_ms NUMERIC,
  max_time_ms NUMERIC,
  rows_affected BIGINT
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    md5(s.query) as query_hash,
    LEFT(s.query, 200) as query_sample,
    s.calls,
    ROUND(s.total_exec_time::NUMERIC, 2) as total_time_ms,
    ROUND(s.mean_exec_time::NUMERIC, 2) as avg_time_ms,
    ROUND(s.max_exec_time::NUMERIC, 2) as max_time_ms,
    s.rows as rows_affected
  FROM pg_stat_statements s
  WHERE s.mean_exec_time > min_duration_ms
    AND s.calls > 5  -- Filter out one-off queries
  ORDER BY s.mean_exec_time DESC
  LIMIT limit_results;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Index usage analysis
CREATE OR REPLACE FUNCTION public.analyze_index_usage()
RETURNS TABLE (
  table_name TEXT,
  index_name TEXT,
  index_size TEXT,
  index_scans BIGINT,
  tuples_read BIGINT,
  tuples_fetched BIGINT,
  usage_ratio NUMERIC
) AS $$
BEGIN
  RETURN QUERY
  SELECT 
    schemaname || '.' || tablename as table_name,
    indexrelname as index_name,
    pg_size_pretty(pg_relation_size(indexrelid)) as index_size,
    idx_scan as index_scans,
    idx_tup_read as tuples_read,
    idx_tup_fetch as tuples_fetched,
    CASE 
      WHEN idx_scan = 0 THEN 0
      ELSE ROUND(100.0 * idx_tup_fetch / NULLIF(idx_tup_read, 0), 2)
    END as usage_ratio
  FROM pg_stat_user_indexes
  WHERE schemaname = 'public'
  ORDER BY idx_scan DESC;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =============================================================================
-- PHASE 4: MATERIALIZED VIEWS FOR ANALYTICS
-- =============================================================================

-- Customer analytics materialized view
CREATE MATERIALIZED VIEW IF NOT EXISTS public.customer_analytics AS
SELECT 
  customer_email,
  COUNT(*) as total_orders,
  COUNT(*) FILTER (WHERE status IN ('paid', 'processing', 'shipped', 'delivered')) as successful_orders,
  SUM(total_amount) FILTER (WHERE status IN ('paid', 'processing', 'shipped', 'delivered')) as total_spent,
  AVG(total_amount) FILTER (WHERE status IN ('paid', 'processing', 'shipped', 'delivered')) as avg_order_value,
  MAX(created_at) as last_order_date,
  MIN(created_at) as first_order_date,
  COUNT(*) FILTER (WHERE created_at >= NOW() - INTERVAL '30 days') as orders_last_30_days,
  STRING_AGG(DISTINCT payment_method, ', ') as payment_methods_used
FROM public.orders 
WHERE created_at >= NOW() - INTERVAL '2 years'  -- Limit to recent data
GROUP BY customer_email
HAVING COUNT(*) > 0;

-- Create unique index on materialized view
CREATE UNIQUE INDEX IF NOT EXISTS idx_customer_analytics_email 
ON public.customer_analytics (customer_email);

-- Product performance materialized view
CREATE MATERIALIZED VIEW IF NOT EXISTS public.product_analytics AS
SELECT 
  p.id,
  p.title,
  p.category,
  p.price,
  p.stock_quantity,
  COALESCE(order_stats.total_sold, 0) as total_sold,
  COALESCE(order_stats.total_revenue, 0) as total_revenue,
  COALESCE(order_stats.order_count, 0) as order_count,
  COALESCE(order_stats.avg_quantity_per_order, 0) as avg_quantity_per_order,
  CASE 
    WHEN order_stats.total_sold > 0 THEN 
      ROUND(order_stats.total_revenue / order_stats.total_sold, 2)
    ELSE p.price 
  END as avg_selling_price
FROM public.products p
LEFT JOIN (
  SELECT 
    (item->>'id')::BIGINT as product_id,
    SUM((item->>'quantity')::INTEGER) as total_sold,
    SUM((item->>'price')::DECIMAL * (item->>'quantity')::INTEGER) as total_revenue,
    COUNT(DISTINCT o.id) as order_count,
    AVG((item->>'quantity')::INTEGER) as avg_quantity_per_order
  FROM public.orders o
  CROSS JOIN jsonb_array_elements(o.items) as item
  WHERE o.status IN ('paid', 'processing', 'shipped', 'delivered')
    AND o.created_at >= NOW() - INTERVAL '1 year'
    AND (item->>'id') IS NOT NULL
  GROUP BY (item->>'id')::BIGINT
) order_stats ON p.id = order_stats.product_id
WHERE p.is_active = true;

-- Create unique index on product analytics
CREATE UNIQUE INDEX IF NOT EXISTS idx_product_analytics_id 
ON public.product_analytics (id);

-- Create additional indexes for common analytics queries
CREATE INDEX IF NOT EXISTS idx_product_analytics_category 
ON public.product_analytics (category, total_sold DESC);

CREATE INDEX IF NOT EXISTS idx_product_analytics_revenue 
ON public.product_analytics (total_revenue DESC);

-- =============================================================================
-- PHASE 5: MAINTENANCE FUNCTIONS
-- =============================================================================

-- Function to refresh materialized views
CREATE OR REPLACE FUNCTION public.refresh_analytics_views()
RETURNS void AS $$
BEGIN
  REFRESH MATERIALIZED VIEW CONCURRENTLY public.customer_analytics;
  REFRESH MATERIALIZED VIEW CONCURRENTLY public.product_analytics;
  
  -- Log the refresh
  RAISE NOTICE 'Analytics views refreshed at %', NOW();
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to analyze table statistics
CREATE OR REPLACE FUNCTION public.update_table_statistics()
RETURNS void AS $$
BEGIN
  ANALYZE public.orders;
  ANALYZE public.products;
  ANALYZE public.coupons;
  ANALYZE public.customer_analytics;
  ANALYZE public.product_analytics;
  
  RAISE NOTICE 'Table statistics updated at %', NOW();
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Performance health check function
CREATE OR REPLACE FUNCTION public.performance_health_check()
RETURNS TABLE (
  check_name TEXT,
  status TEXT,
  details TEXT,
  recommendation TEXT
) AS $$
BEGIN
  -- Check index usage
  RETURN QUERY
  SELECT 
    'unused_indexes' as check_name,
    CASE WHEN COUNT(*) = 0 THEN 'good' ELSE 'warning' END as status,
    FORMAT('%s unused indexes found', COUNT(*)) as details,
    CASE WHEN COUNT(*) > 0 THEN 'Consider dropping unused indexes' ELSE 'All indexes are being used' END as recommendation
  FROM pg_stat_user_indexes 
  WHERE schemaname = 'public' AND idx_scan = 0 AND indexrelname NOT LIKE 'idx_%_pkey';
  
  -- Check slow queries
  RETURN QUERY
  SELECT 
    'slow_queries' as check_name,
    CASE WHEN COUNT(*) < 5 THEN 'good' WHEN COUNT(*) < 15 THEN 'warning' ELSE 'critical' END as status,
    FORMAT('%s slow queries in last hour', COUNT(*)) as details,
    CASE 
      WHEN COUNT(*) >= 15 THEN 'Immediate optimization needed'
      WHEN COUNT(*) >= 5 THEN 'Monitor and optimize slow queries'
      ELSE 'Query performance looks good'
    END as recommendation
  FROM pg_stat_statements 
  WHERE last_exec > NOW() - INTERVAL '1 hour' AND mean_exec_time > 1000;
  
  -- Check connection count
  RETURN QUERY
  SELECT 
    'connection_usage' as check_name,
    CASE WHEN COUNT(*) < 50 THEN 'good' WHEN COUNT(*) < 80 THEN 'warning' ELSE 'critical' END as status,
    FORMAT('%s active connections', COUNT(*)) as details,
    CASE 
      WHEN COUNT(*) >= 80 THEN 'Consider connection pooling optimization'
      WHEN COUNT(*) >= 50 THEN 'Monitor connection usage'
      ELSE 'Connection usage is healthy'
    END as recommendation
  FROM pg_stat_activity WHERE state = 'active';
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- =============================================================================
-- PHASE 6: SECURITY AND PERMISSIONS
-- =============================================================================

-- Grant necessary permissions for monitoring functions
GRANT EXECUTE ON FUNCTION public.get_slow_queries(INTEGER, INTEGER) TO authenticated;
GRANT EXECUTE ON FUNCTION public.analyze_index_usage() TO authenticated;
GRANT EXECUTE ON FUNCTION public.performance_health_check() TO authenticated;

-- Service role gets full access for maintenance
GRANT ALL ON public.customer_analytics TO service_role;
GRANT ALL ON public.product_analytics TO service_role;
GRANT EXECUTE ON ALL FUNCTIONS IN SCHEMA public TO service_role;

-- Authenticated users can read analytics (for admin dashboard)
GRANT SELECT ON public.customer_analytics TO authenticated;
GRANT SELECT ON public.product_analytics TO authenticated;
GRANT SELECT ON public.database_performance TO authenticated;

-- =============================================================================
-- VALIDATION AND COMPLETION
-- =============================================================================

-- Validate all indexes were created successfully
DO $$
DECLARE
  missing_indexes TEXT[];
  expected_indexes TEXT[] := ARRAY[
    'idx_orders_items_gin',
    'idx_orders_customer_status_date', 
    'idx_products_catalog_active',
    'idx_orders_recent',
    'idx_customer_analytics_email',
    'idx_product_analytics_id'
  ];
  idx TEXT;
BEGIN
  FOREACH idx IN ARRAY expected_indexes
  LOOP
    IF NOT EXISTS (
      SELECT 1 FROM pg_indexes 
      WHERE schemaname = 'public' AND indexname = idx
    ) THEN
      missing_indexes := array_append(missing_indexes, idx);
    END IF;
  END LOOP;
  
  IF array_length(missing_indexes, 1) > 0 THEN
    RAISE WARNING 'Missing indexes: %', array_to_string(missing_indexes, ', ');
  ELSE
    RAISE NOTICE 'All performance indexes created successfully!';
  END IF;
END $$;

-- Initial refresh of materialized views
SELECT public.refresh_analytics_views();
SELECT public.update_table_statistics();

-- Log migration completion
INSERT INTO public.orders (
  customer_email, 
  items, 
  shipping_address, 
  shipping_option, 
  payment_method, 
  status,
  notes
) VALUES (
  'system@anointarray.com',
  '[{"id": "migration", "title": "Performance Migration", "price": 0, "quantity": 1}]'::jsonb,
  '{"name": "System", "address": "Migration Log"}'::jsonb,
  '{"id": "system", "name": "System Process", "price": 0}'::jsonb,
  'system',
  'completed',
  'Performance optimization migration 002 completed successfully at ' || NOW()::TEXT
) ON CONFLICT DO NOTHING;

-- Final performance check
SELECT * FROM public.performance_health_check();